rcon = [0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a]
"""
sbox = [103, 172, 53, 159, 102, 168, 133, 197, 174, 182, 41, 164, 220, 58, 118, 63,
  161, 50, 89, 242, 253, 74, 250, 119, 108, 122, 120, 216, 60, 208, 178, 20,
   180, 187, 117, 213, 48, 90, 218, 46, 190, 188, 111, 252, 56, 77, 169, 232,
    135, 72, 44, 115, 130, 57, 96, 155, 105, 181, 83, 0, 204, 139, 9, 7,
     138, 23, 145, 97, 185, 13, 254, 69, 24, 34, 158, 76, 222, 165, 2, 247,
     226, 6, 183, 116, 206, 21, 225, 210, 219, 36, 129, 100, 141, 62, 198, 28,
      207, 84, 184, 99, 160, 215, 52, 73, 153, 42, 191, 26, 162, 194, 235, 81,
       238, 110, 43, 214, 234, 221, 70, 80, 148, 176, 251, 245, 151, 244, 132, 14,
        29, 94, 137, 131, 189, 31, 231, 47, 68, 8, 11, 249, 243, 37, 203, 200,
         202, 255, 236, 112, 51, 10, 98, 79, 19, 59, 228, 177, 192, 75, 85, 45,
          121, 27, 147, 179, 1, 201, 123, 18, 167, 166, 239, 146, 49, 196, 163, 109,
           15, 143, 144, 150, 65, 106, 25, 124, 54, 241, 16, 92, 227, 217, 104, 173,
            223, 86, 113, 39, 157, 199, 126, 71, 33, 61, 38, 142, 87, 22, 237, 152,
             55, 212, 248, 175, 149, 170, 246, 88, 17, 64, 209, 171, 240, 224, 154, 211,
              78, 93, 205, 114, 136, 12, 40, 101, 5, 95, 233, 35, 186, 195, 230, 127,
               91, 229, 193, 32, 30, 4, 140, 66, 134, 128, 125, 82, 3, 67, 107, 156]
ptable = [
    16, 19, 23, 9, 22, 20, 21, 17, 
    40, 43, 44, 47, 41, 45, 57, 42, 
    36, 32, 38, 33, 55, 37, 34, 35, 
    50, 53, 48, 52, 39, 54, 49, 51, 
    10, 11, 14, 8, 13, 15, 18, 12, 
    0, 7, 2, 3, 4, 1, 5, 31, 
    63, 46, 58, 62, 61, 59, 56, 60, 
    6, 29, 25, 24, 30, 27, 28, 26
]
"""
sbox = [62, 117, 195, 179, 20, 210, 41, 66, 116, 178, 152, 143, 75, 105, 254, 1, 
        158, 95, 101, 175, 191, 166, 36, 24, 50, 39, 190, 120, 52, 242, 182, 185, 
        61, 225, 140, 38, 150, 80, 19, 109, 246, 252, 40, 13, 65, 236, 124, 186, 214, 86, 235, 100, 97, 49, 197, 154, 176, 199, 253, 69, 88, 112, 139, 77, 184, 45, 133, 104, 15, 54, 177, 244, 160, 169, 82, 148, 73, 30, 229, 35, 79, 137, 157, 180, 248, 163, 241, 231, 81, 94, 165, 9, 162, 233, 18, 85, 217, 84, 7, 55, 63, 171, 56, 118, 237, 132, 136, 22, 90, 221, 103, 161, 205, 11, 255, 14, 122, 47, 71, 201, 99, 220, 83, 74, 173, 76, 144, 16, 155, 126, 60, 96, 44, 234, 17, 215, 107, 138, 159, 183, 251, 3, 198, 0, 89, 170, 131, 151, 219, 29, 230, 32, 187, 125, 134, 64, 12, 202, 164, 247, 25, 223, 222, 119, 174, 67, 147, 146, 206, 51, 243, 53, 121, 239, 68, 130, 70, 203, 211, 111, 108, 113, 8, 106, 57, 240, 21, 93, 142, 238, 167, 5, 128, 72, 189, 192, 193, 92, 10, 204, 87, 145, 188, 172, 224, 226, 207, 27, 218, 48, 33, 28, 123, 6, 37, 59, 4, 102, 114, 91, 23, 209, 34, 42, 2, 196, 141, 208, 181, 245, 43, 78, 213, 216, 232, 46, 98, 26, 212, 58, 115, 194, 200, 129, 227, 249, 127, 149, 135, 228, 31, 153, 250, 156, 168, 110]


NL = [[-128 for _ in range(256)] for _ in range(256)]

# https://github.com/lucastsa/crypto-spn/blob/master/docs/report.pdf

# http://p-nand-q.com/python/algorithms/math/bit-parity.html
def parity_kr(v):
    v ^= v >> 16
    v ^= v >> 8
    v ^= v >> 4
    v &= 0xf
    return (0x6996 >> v) & 1

for i in range(256):
    output = sbox[i]
    for m_i in range(256):
        m_ii = i & m_i
        for m_o in range(256):
            m_oo = output & m_o
            if (parity_kr(m_ii ^ m_oo) == 0):
                NL[m_i][m_o] += 1
# print NL
"""
m = 0
posi = 0
posj = 0
for i in range(256):
    for j in range(256):
        if (abs(NL[i][j]) > m and abs(NL[i][j]) < 128 ):
            m = abs(NL[i][j])
            posi = i
            posj = j

print (m, posi, posj)
# print NL[16]

"""
biastable = {}

for i in range(256):
    for j in range(256):
        if (abs(NL[i][j]) > 32 and abs(NL[i][j]) < 128):
            biastable[(i,j)] = abs(NL[i][j])

# print biastable


# manually construct full linear approx chain

def getdigit(x,i):
    if (x & (1 << (7-i)) != 0):
        return 1
    else:
        return 0

plaintext = []
ciphertext = []
f = open('dataSPN','r')
for _ in range(65536):
    plaintext.append(f.read(8))
    ciphertext.append(f.read(8))
f.close()

count = [[0 for _ in range(256)] for _ in range(256)]

paircount = 65536


# recover k^(4): 1) x2^x3^x4^x5^x7^u27^u31^u59^u63
# 2) x11^x12^x15^u0^u6^u48^u54
# 3) x0^u3^u7^u11^u15^u19^u23^u27^u31^u51^u55
k0 = 130
k3 = 65
k6 = 194
for i in range(paircount):
    if (i % 256 == 0):
        print "Testing pair #", i
    p = ord(plaintext[i][0])
    x0 = getdigit(p,0)
    for k1 in range(256):
        for k2 in range(256):
            b0 = sbox.index(ord(ciphertext[i][0])^k0)
            b1 = sbox.index(ord(ciphertext[i][1])^k1)
            b2 = sbox.index(ord(ciphertext[i][2])^k2)
            b3 = sbox.index(ord(ciphertext[i][3])^k3)
            b6 = sbox.index(ord(ciphertext[i][6])^k6)
            u3 = getdigit(b0,3)
            u7 = getdigit(b0,7)
            u11 = getdigit(b1,3)
            u15 = getdigit(b1,7)
            u19 = getdigit(b2,3)
            u23 = getdigit(b2,7)
            u27 = getdigit(b3,3)
            u31 = getdigit(b3,7)
            u51 = getdigit(b6,3)
            u55 = getdigit(b6,7)
            if ((x0^u3^u7^u11^u15^u19^u23^u27^u31^u51^u55) == 0):
                count[k1][k2] += 1

print count

keybias = [[0 for _ in range(256)] for _ in range(256)]

m = 1
mk1 = 0
mk2 = 0
for k1 in range(256):
    for k2 in range(256):
        count[k1][k2] = count[k1][k2] * 1.0 / (paircount)
        count[k1][k2] -= 0.5
        keybias[k1][k2] = abs(abs(count[k1][k2]) - 0.01252219)
        if keybias[k1][k2] < m :
            m = keybias[k1][k2]
            mk1 = k1
            mk2 = k2

print m, (mk1,mk2)


